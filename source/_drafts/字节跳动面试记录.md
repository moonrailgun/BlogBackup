---
title: 字节跳动面试记录
tags:
  - 字节跳动
  - 面试
date: 2021-04-01 16:13:45
---

## 一面

关于项目:

- 抽象结构树
  - 如何根据一颗 AST 渲染出组件
- 富文本编辑器
  - 实现的难点

常规问题:

- webpack 打包细节
  - commonjs 与 esmodule 是如何相互转换(这里不会)
- Task 与 Microtask 的区别, 以及时序

  详细说明可以见: https://html.spec.whatwg.org/multipage/webappapis.html#queuing-tasks

  简单的说就是每次执行`task`之前会把`microtask`都处理掉。在处理过程中加入的`microtask`也会按照顺序处理掉

- 闭包问题:

  ```javascript
  for (var i = 0; i < 5; i++) {
    setTimeout(() => {
      console.log(i);
    }, 1000);
  }
  ```

  结果是什么? (我回答了`5个4`, 其实是`5个5`..扶额)

  然后问如何让其输出 0 1 2 3 4
  解法一:

  ```javascript
  for (var i = 0; i < 5; i++) {
    (function (_i) {
      setTimeout(() => {
        console.log(_i);
      }, 1000);
    })(i);
  }
  ```

  解法二:

  ```javascript
  for (let i = 0; i < 5; i++) {
    setTimeout(() => {
      console.log(i);
    }, 1000);
  }
  ```

  我没有说出解法二, 想了半天想出了一个解法三。。

  ```javascript
  for (var i = 0; i < 5; i++) {
    Promise.resolve(i).then((i) => {
      setTimeout(() => {
        console.log(i);
      }, 1000);
    });
  }
  ```

- 中文数字转阿拉伯数字

  ```typescript
  // 五千三百万零五百零一

  const chineseNumMap = {
    一: 1,
    二: 2,
    三: 3,
    四: 4,
    五: 5,
    六: 6,
    七: 7,
    八: 8,
    九: 9,
  };

  const unitMap = {
    千: 1000,
    百: 100,
    十: 10,
  };

  function parseChineseNumWhenLowerThan10K(chineseNum: string) {
    let res = 0;
    let hasNum = false;
    let currentNum = 0;
    for (const s of chineseNum) {
      if (hasNum === false && chineseNumMap[s]) {
        res += chineseNumMap[s];
        hasNum = true;
        currentNum = chineseNumMap[s];
      } else if (hasNum === true && unitMap[s]) {
        res -= currentNum;
        res += currentNum * unitMap[s];
        hasNum = false;
        currentNum = 0;
      }
    }

    return res;
  }

  function chineseNumToInt(input: string): number {
    const chineseNumArr = input.split("万");
    let res = 0;

    res += parseChineseNumWhenLowerThan10K(chineseNumArr[0]);

    if (typeof chineseNumArr[1] === "string") {
      res *= 10000;
      res += parseChineseNumWhenLowerThan10K(chineseNumArr[1]);
    }

    return res;
  }

  console.log(chineseNumToInt("五千三百万零五百零一"));
  ```

## 二面

一面过后第二天 HR 就打电话过来约二面，就效率方面来说还是非常迅速的

二面没有考察具体代码，主要是问了问项目方面的问题。

比如公司项目的架构，公司团队协作方面是如何协作的，除了平时工作之外有没有做什么其他的事情，有自己的项目么，自己的项目由什么亮点难点这种比较抽象的问题。

其中可能也有混入价值观方面的问题。总之需要注意一下。

然后我这面被刷了，第三天收到了感谢面试的信。至少有个反馈，从这点来看字节做的还是非常不错的。

# 再战

又被别的部门捞起来了, 之前是飞书, 现在是抖音部门, 就再战一次呗。

## 一面

- 聊聊项目
- esmodule 和 commonjs 的区别
- webpack 打包原理
- nodejs 的 event loop
- nodejs 的使用 microtask 和 task 的时机

### 算法题

路径总和：给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum

```typescript
class TreeNode {
  left: TreeNode | null = null;
  right: TreeNode | null = null;
  value: number;
}

function getTreePathSum(node: TreeNode, targetSum: number): boolean {
  if (!node) {
    return false;
  }

  if (targetSum - node.value === 0) {
    if (node.left === null && node.right === null) {
      // 如果为叶子节点: 即没有子节点
      return true;
    }

    // 否则继续往下走。
  }

  return (
    getTreePathSum(node.left, targetSum - node.value) ||
    getTreePathSum(node.right, targetSum - node.value)
  );
}

const root = new TreeNode();
root.value = 1;
const left = new TreeNode();
left.value = 2;
const right = new TreeNode();
right.value = 3;

root.left = left;
root.right = right;

console.log(getTreePathSum(root, 5));
```


## 二面

- js有哪些类型
  - ~~`number`, `boolean`, `string`, `object`, `undefined`, `symbol`~~
  - 以上是我的回答, 是错误答案，正确答案应该是 `string`, `number`, `bigint`, `boolean`, `undefined`, `symbol`, `null`. (Reference: https://developer.mozilla.org/en-US/docs/Glossary/Primitive)
- js中基本类型和引用类型分别存在哪里
  - 基本类型存在栈中，引用类型的数据存在堆中
- 如何获得地址输入 - 缓存 - 加载模块 - 渲染 - 加载请求 - 渲染可交互 这个过程中各个区域的时延
- 如何设计一个全链路的监控体系
  我的回答:
  ```
  1. 监听所有的用户事件
    并区分重点事件，和普通事件。
  2. 全局捕获错误信息。并将错误信息上报，以及错误信息所在的堆栈信息。
          如果可能的话，同时发送相关的dom接口与网络请求，以及截屏。
          如果是无法复现的一些线上问题，内置一个web录屏工具，在开启一个flag后录屏并将录屏信息上传(rrweb)
  3. 对用户的操作，比如RUM，等关键信息，以及用户的请求。划分不同的measure标准。并通过这些信息来衡量用户的痛苦程度。
        资源是有限的，我们应当优先处理用户最痛苦的部分——即使用频率最高，相对痛苦程度最高的部分。
  4. 增加有效的反馈机制，比如聊天机器人，比如报出异常时弹出反馈错误的模态框。或者引导用户到相关的社区。来尽可能让用户知晓我们会尽快解决问题。
      同时能够收集来自用户的直接反馈，而这些是看log很难看到的信息。
  5. 对线上服务进行监控。使用监控工具来检测各个关键服务，以及相对独立的服务的可访问性。以及相关的报警措施(比如钉钉消息)
  ```
- React Native 的热更新 / 部署
  - 拆解
  - 怎么推送
- 长列表 VirturalList
  - 如何解决闪屏
- React Native的事件推送

### 算法题

二面算法题难度急速升高, 反正我都没做过。

```
用 Javascript 对象模拟 DOM 树，并实现它的 render 方法，通过调用该方法可以转成真正的 DOM 节点，例如我们已经实现了 element.js，通过 require('element.js')，我们可以定义 ul， 如下：

function el(tag, props, children) {
  return ...
}
```

我的算法:
```js
function el(tag, props, children) {
  const el = document.createElement(tag);
  for(let key in props) {
      el.setAttrible(key, props[key])
  }

  const childrenEls = children.map(item => {
      if(typeof item === 'string') {
          return item;
      }

      return el(item.tag, item.props, item.children);
  })
  el.append(...childrenEls)

  return el;
}
```

```
给你一副类似于如下的地图:
 0000000000
 0010001011
 000010E001
 00S0000100
 0000001000
 1000000000

初始时你在S的位置, 你可以向上下左右四个方向发射一枚子弹; 子弹碰到1时, 会顺时针变向90度, 然后继续前进; 问你在S向哪个方向射击, 能够最快将子弹打入E内; 假设一定有一个方向可以成功, 如上图中向上射击;
```

我的算法:
```typescript
const land = [
  '0000000000',
  '0010001011',
  '000010E001',
  '00S0000100',
  '0000001000',
  '1000000000'
].map((str) => {
  return str.split('')
});

function findS(target: string): [number, number] {
  for(let i = 0; i < land.length; i++) {
    for(let j = 0; j < land[i].length; j++) {
      if(land[i][j] === target) {
        return [i, j]
      }
    }
  }
}

function getLandSymbol(y: number, x: number): '0' | '1' | 'S' | 'E' | undefined {
  return land[y][x] as any
}

const size = [land.length, land[0].length];
const sPos = findS('S');

function tryPath(step: number, currentPos: [number,number], vector: [number, number]): number {
  step = step + 1;
  const symbol = getLandSymbol(currentPos[0], currentPos[1])
  if(symbol === '1') {
    // [-1. 0] => [0, 1]
    // [0, 1] => [1, 0]
    // [1, 0] => [0, -1]
    // [-1, 0] => [0, 1]
    vector = [vector[1], -vector[0]] // 顺时针旋转90deg
  }else if(symbol === 'E') {
    return step;
  }else if(symbol === undefined) {
    return 999999
  }

  return tryPath(step, [currentPos[0] + vector[0], currentPos[1] + vector[1]], vector);
}
console.log(tryPath(0, sPos, [-1, 0])); // 向上
```
